Перем мКартинкаВстроеннойСправкиФормы;

// ----------------------------------------------------------------------------------------------------
//  Функции для вызова из конфигуратора
// ----------------------------------------------------------------------------------------------------

// Для открытия из конфигуратора (вычислить выражение, CTRL+F9), например
//  ВнешниеОтчеты.Создать("f:\Выполнение запроса\нкВыполнениеЗапроса.epf").ОткрытьДляОтладки(Запрос)
Функция ОткрытьДляОтладки(знач Запрос) Экспорт
	Если ТипЗнч(Запрос)<>Тип("Запрос") и ТипЗнч(Запрос)<>Тип("ПостроительОтчета") Тогда
		Возврат "Ошибка:  Переданный объект не является запросом или построителем отчета!";
	КонецЕсли;
	Форма = ПолучитьФорму("ОсновнаяФорма");
	Форма.ТекстЗапроса = Запрос.Текст;
	глозЗаполнитьПараметрыИзЗапроса(Запрос, Форма.ПараметрыЗапроса, Форма.НачПериода, Форма.КонПериода);
	Форма.мНеЗагружатьНастройки = Истина;
	Форма.ЭлементыФормы.ДействияФормы.Кнопки.Файл.Кнопки.Автосохранение.Пометка = Ложь;
	Форма.Открыть();
	Возврат "Запрос открыт для отладки";
КонецФункции

// Две функции для разбора сложных составных запросов
// Идея от ssn1978, http://infostart.ru/public/19577/
//
// не отлазживалось...
Функция СоздатьПакетЗапросов(Запрос) Экспорт
	Перем Структура;
	Если ТипЗнч(Запрос)<>Тип("Запрос") и ТипЗнч(Запрос)<>Тип("ПостроительОтчета") Тогда
		Возврат "Ошибка:  Переданный объект не является запросом или построителем отчета!";
	КонецЕсли;
	Структура = Новый Структура("Версия,ТекстЗапроса,Параметры");
	Структура.Версия = "Отладчик пакета запросов формат 1.0";
	Структура.ТекстЗапроса = Запрос.Текст;
	Структура.Параметры = Запрос.Параметры;
	ЗначениеВФайл(глозПолучитьИмяФайлаСохраненияПакетаЗапросов(), Структура);
	Возврат "Новый пакет создан";
КонецФункции

Функция ДобавитьЗапросВПакет(Запрос) Экспорт
	Перем ИмяФайла, Структура, Параметр;
	Если ТипЗнч(Запрос)<>Тип("Запрос") и ТипЗнч(Запрос)<>Тип("ПостроительОтчета") Тогда
		Возврат "Ошибка:  Переданный объект не является запросом или построителем отчета!";
	КонецЕсли;
	ИмяФайла = глозПолучитьИмяФайлаСохраненияПакетаЗапросов();
	Попытка
		Структура = ЗначениеИзФайла(ИмяФайла);
		Если Структура.Версия<>"Отладчик пакета запросов формат 1.0" Тогда
			ВызватьИсключение "Abort";
		КонецЕсли;
	Исключение
		СоздатьПакетЗапросов(Запрос);
	КонецПопытки;
	Структура.ТекстЗапроса = Структура.ТекстЗапроса + ";
	|
	|////////////////////////////////////////////////////////////////////////////
	|
	|"+Запрос.Текст;
	СтруктураПараметры = Структура.Параметры;
	Для каждого Параметр Из Запрос.Параметры Цикл
		Если НЕ СтруктураПараметры.Свойство(Параметр.Ключ) Тогда
			СтруктураПараметры.Вставить(Параметр.Ключ, Параметр.Значение);
		КонецЕсли;
	КонецЦикла;
	Возврат "Запрос добавлен в пакет";
КонецФункции

// ----------------------------------------------------------------------------------------------------
//  Функции для простейшего парсинга запросов
// ----------------------------------------------------------------------------------------------------

Функция глозПолучитьНаборСимволов(ИмяНабора, ВерхнийРегистр=Истина) Экспорт
	Если ИмяНабора="Цифры" Тогда
		Возврат "0123456789";
	ИначеЕсли ИмяНабора = "БуквыРус" и ВерхнийРегистр Тогда
		Возврат "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ";
	ИначеЕсли ИмяНабора = "БуквыРус" и НЕ ВерхнийРегистр Тогда
		Возврат "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	ИначеЕсли ИмяНабора = "БуквыАнгл" и ВерхнийРегистр Тогда
		Возврат "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	ИначеЕсли ИмяНабора = "БуквыАнгл" и НЕ ВерхнийРегистр Тогда
		Возврат "abcdefghijklmnopqrstuvwxyz";
	ИначеЕсли ИмяНабора = "МатемаатическиеСимволы" Тогда
		Возврат "+-*/^";
	Иначе
		Возврат "";
	КонецЕсли;
КонецФункции

// Функции примитивного (т.е. простейшего) парсинга
//
Функция глозКонецСлова(Знач Стр, ДопустимыеСимволы)	
	Если ДопустимыеСимволы<>"" Тогда
		Стр = ВРег(Стр);
		СД = СтрДлина(Стр);
		Р = 1;
		Пока Р<СД Цикл
			Если Найти(ДопустимыеСимволы, Сред(Стр, Р, 1))<1 Тогда
				Возврат Р;
			КонецЕсли;
			Р=Р+1;
		КонецЦикла;
	КонецЕсли;
	Возврат СтрДлина(Стр)+1;
КонецФункции

Функция глозПозицияПробела(Знач Стр)
	ДопустимыеСимволы = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ" + "0123456789" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "_"+".";
	Возврат глозКонецСлова(Стр, ДопустимыеСимволы);
КонецФункции

// Находит в исходном тексте Текст слово, которому предшествует Слово1 
// и это слово находится между словами КавычкаСлева и КавычкаСправа
//
// Например:
//		Текст = "У Коли телефон _Nokia_, а Саши телефон марки _Samsung_.";
//		Сообщить(СловоМежду(Текст, "Саши", "_", "_"));
// Результат: Samsung
//
// Полезно при примитивном парсинге, например, HTML-кода страницы.
//
Функция глозСловоМежду(знач Текст, Слово1, КавычкаСлева="""", КавычкаСправа="""") Экспорт
	Перем п;
	п=Найти(врег(Текст), врег(Слово1));
	Если п<1 Тогда
		Возврат "";
	КонецЕсли;
	Текст = Сред(Текст, п+СтрДлина(Слово1));
	п=Найти(врег(Текст), врег(КавычкаСлева));
	Если п<1 Тогда
		Возврат "";
	КонецЕсли;
	Текст = Сред(Текст, п+СтрДлина(КавычкаСлева));
	п=Найти(врег(Текст), врег(КавычкаСправа));
	Если п<1 Тогда
		Возврат "";
	КонецЕсли;
	Возврат Лев(Текст, п-1);
КонецФункции

// Улучшенная версия преобразования строки ва число.
// Пример ВЧисло("Итого = 3120,50"); // вернет число 3120.50
Функция глозВЧисло(знач Текст, ЗначениеПоУмолчанию=0) Экспорт	
	Цифры = глозПолучитьНаборСимволов("Цифры")+"-.";
	т = СокрЛП(СтрЗаменить(СтрЗаменить(СтрЗаменить(Текст, " ", ""), Символы.НПП, ""),",","."));
	Текст = "";
	Для сч=1 по СтрДлина(т) Цикл
		Буква = Сред(т, сч, 1);
		Если Найти(Цифры, Буква)>0 Тогда
			Текст = Текст+Буква;
		КонецЕсли;
	КонецЦикла;
	сч = ?(Лев(Текст, 1)="-", 2, 1);
	Пока Лев(Текст, сч)="0" Цикл
		Текст = Сред(Текст, 2);
	КонецЦикла;
	Попытка
		Возврат Число(Текст);
	Исключение
		Возврат ЗначениеПоУмолчанию;
	КонецПопытки;
КонецФункции

Функция глозНайтиПараметрыВЗапросеСОшибками(ТекстЗапроса)
	Ответ = Новый ТаблицаЗначений;
	Ответ.Колонки.Добавить("Имя");
	Ответ.Колонки.Добавить("ТипЗначения");
	Ответ.Колонки.Добавить("Значение");
КонецФункции

// Вспомогательные функции
Процедура глозЗаполнитьПараметрыИзЗапроса(Запрос, ТЗ, НП, КП) Экспорт
	Перем Параметр, НС;
	ПДатыНач = ВРЕГ(",НачПериода,НачальнаяДата,ДатаНач,НачДата,ДатаНачала,НачальнаяДата,");
	ПДатыКон = ВРЕГ(",КонПериода,КонечнаяДата,ДатаКон,КонДата,ДатаКонца,КонечнаяДата,Дата,");
	ТипТЗ = Тип("ТаблицаЗначений");
	ТипМассив = Тип("Массив");
	ТипГраница = Тип("Граница");
	ТипМоментВремени = Тип("МоментВремени");
	ТипДата = Тип("Дата");
	фл = Истина;
	Попытка
		ТабПараметры = Запрос.НайтиПараметры();
	Исключение
		фл = Ложь;
	КонецПопытки;
	Для каждого Параметр Из Запрос.Параметры Цикл
		ТекТипДанных = ТипЗнч(Параметр.Значение);
		НС = ТЗ.Добавить();
		ИмяПараметра = Параметр.Ключ;
		НС.ИмяПараметра = ИмяПараметра;
		ТекПараметр = ?(фл, ТабПараметры.Найти(Параметр.Ключ), Неопределено);
		Если ТекПараметр<>Неопределено Тогда
			НС.ТипДанных = ТекПараметр.ТипЗначения;
		Иначе
			мТип = Новый Массив();
			мТип.Добавить(ТекТипДанных);
			НС.ТипДанных =  Новый ОписаниеТипов(мТип);
		КонецЕсли;
		Если ТекТипДанных=ТипТЗ или ТекТипДанных=ТипГраница или ТекТипДанных=ТипМоментВремени Тогда
			НС.ТЗ = ЗначениеВСтрокуВнутр(Параметр.Значение);
			мТип = Новый Массив();
			мТип.Добавить(ТекТипДанных);
			НС.ТипДанных =  Новый ОписаниеТипов(мТип);
		ИначеЕсли ТекТипДанных=ТипМассив Тогда
			СЗ = Новый СписокЗначений;
			СЗ.ЗагрузитьЗначения(Параметр.Значение);
			НС.Значение = СЗ;
		Иначе
			НС.Значение = Параметр.Значение;
			Если ТекТипДанных=ТипДата и Найти(ПДатыНач, ","+ВРег(ИмяПараметра)+",")>0 Тогда
				НП = Параметр.Значение;
			ИначеЕсли ТекТипДанных=ТипДата и Найти(ПДатыКон, ","+ВРег(ИмяПараметра)+",")>0 Тогда
				КП = Параметр.Значение;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Преобразовывает имя переменной к более читабельному виду, аналогично внутренним алгоритмам 1С
// Например "ОбменСБазой" -> "Обмен с базой"
Функция глозПредставлениеПеременной(знач ИмяПеременной) Экспорт
	Перем МаленькиеБуквы, Цифры, Буква, Ответ, сч, ПредыдущаяБуква, СледующаяБуква;
	ИмяПеременной = СокрЛП(ИмяПеременной);
	МаленькиеБуквы = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя_";
	Цифры="0123456789.";
	Буква = Лев(ИмяПеременной, 1);
	Ответ = ""+Буква;
	Для сч=2 По СтрДлина(ИмяПеременной) Цикл
		ПредыдущаяБуква = Буква;
		Буква = Сред(ИмяПеременной, сч, 1);
		Если (Найти(МаленькиеБуквы, Буква)=0) и (Найти(МаленькиеБуквы, ПредыдущаяБуква)>0) Тогда
			СледующаяБуква = Сред(ИмяПеременной, сч+1, 1);
			Если (СледующаяБуква<>"") и (Найти(МаленькиеБуквы, СледующаяБуква)>0) Тогда
				Буква = НРег(Буква);
			КонецЕсли;
			Буква = " "+Буква;
		ИначеЕсли (Найти(Цифры, Буква)>0) и (Найти(Цифры, ПредыдущаяБуква)=0) Тогда
			Буква = " "+Буква;
		КонецЕсли;
		Ответ = Ответ + Буква;
	КонецЦикла;
	Ответ = СтрЗаменить(Ответ, "_", " ");
	Пока Найти(Ответ, "  ")>0 Цикл Ответ = СтрЗаменить(Ответ, "  ", " ") КонецЦикла;
	Возврат Ответ;
КонецФункции

Функция глозПолучитьИмяФайлаСохраненияПакетаЗапросов() Экспорт
	Перем ИмяФайла;
	ИмяФайла = КаталогВременныхФайлов();
	Возврат ИмяФайла + ?(Прав(ИмяФайла, 1)="\", "", "\")+"ПакетныйЗапрос.1qd";
КонецФункции

Функция глозЭтоВнешнийОбъект() Экспорт
	Возврат (ВРЕГ(Лев(СокрЛ(Метаданные().ПолноеИмя()), 5)) = "ВНЕШН");
КонецФункции

Функция глозЭтоОтчет() Экспорт
	Возврат (Найти(ВРЕГ(Метаданные().ПолноеИмя()), "ОТЧЕТ")>0);
КонецФункции

Функция глозПолучитьСтрокуКодаСоздания() Экспорт
	Если глозЭтоВнешнийОбъект() Тогда
		Возврат СокрЛП("Внешние"+?(глозЭтоОтчет(), "Отчеты", "Обработки")+".Создать("""+ЭтотОбъект.ИспользуемоеИмяФайла+""")");
	Иначе				
		Возврат СокрЛП(""+?(глозЭтоОтчет(), "Отчеты", "Обработки")+"."+ЭтотОбъект.Метаданные().Имя+".Создать()");
	КонецЕсли;
КонецФункции

Функция глозПолучитьСтрокуКодаВызоваФормы(ИмяФормы) Экспорт
	Если глозЭтоВнешнийОбъект() Тогда
		Возврат СокрЛП("Внешние"+?(глозЭтоОтчет(), "Отчеты", "Обработки")+".ПолучитьФорму("""+ЭтотОбъект.ИспользуемоеИмяФайла+""", """+ИмяФормы+""")");
	Иначе				
		Возврат СокрЛП(""+?(глозЭтоОтчет(), "Отчеты", "Обработки")+"."+ЭтотОбъект.Метаданные().Имя+".ПолучитьФорму("""+ИмяФормы+""")");
	КонецЕсли;
КонецФункции

Функция глозФайлСуществует(ИмяФайла) Экспорт
	Перем Файл, Ответ;
	Если ПустаяСтрока(ИмяФайла) Тогда
		Возврат Ложь;
	КонецЕсли;
	Файл = Новый Файл(ИмяФайла);
	Ответ = Файл.Существует();
	Файл = Неопределено;
	Возврат Ответ;
КонецФункции

Процедура глозДобавитьФайлВИсторию(ИмяФайла) Экспорт
	#Если Клиент Тогда
	СЗ = ВосстановитьЗначение("нкОтладчик_ИсторияФайлов");
	Если ТипЗнч(СЗ)<>Тип("Массив") Тогда
		СЗ = Новый Массив();
	КонецЕсли;
	Если СЗ.Найти(ИмяФайла)<>Неопределено Тогда
		СЗ.Удалить(СЗ.Найти(ИмяФайла));
	КонецЕсли;
	СЗ.Вставить(0, ИмяФайла);
	кол = СЗ.Количество(); пока кол>100 цикл кол = кол-1; СЗ.Удалить(кол) конеццикла;
	СохранитьЗначение("нкОтладчик_ИсторияФайлов", СЗ);
	#КонецЕсли
КонецПроцедуры

Функция глозВыбратьИзСпискаНескольких(Список, Заголовок="") Экспорт
	Перем Форма, Ответ;
	Форма = ПолучитьФорму("МножественныйВыбор");
	Форма.Заголовок = ?(Заголовок="", Форма.Заголовок, Заголовок);
	Форма.СЗ = Список.Скопировать();
	Если Форма.ОткрытьМодально()=Истина Тогда
		Ответ = Форма.СЗ.Скопировать();
		Возврат Ответ;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

//основано на: http://infostart.ru/public/163853/
//совсем немного оптимизировал...
Функция глозНоваяТаблицаЗначений(знач ИменаКолонокЧерезЗапятую) Экспорт
    Перем Результат, КолонкиРезультата, МассивИменКолонок;
	ИменаКолонокЧерезЗапятую = СтрЗаменить(СтрЗаменить(СтрЗаменить(ИменаКолонокЧерезЗапятую, Символы.Таб, ""), Символы.ПС, ""), " ", "");
	Результат = Новый ТаблицаЗначений;
	КолонкиРезультата = Результат.Колонки;
	//---> //http://infostart.ru/public/71130/#Pro_bystrye_massivy
	МассивИменКолонок = ЗначениеИзСтрокиВнутр("{""#"",51e7a0d2-530b-11d4-b98a-008048da3034,{0,{""S"",""" + СтрЗаменить(СтрЗаменить(ИменаКолонокЧерезЗапятую, """", """"""), ",", """},{""S"",""") + """}}}");
    Для Каждого ИмяКолонки Из МассивИменКолонок Цикл КолонкиРезультата.Добавить(ИмяКолонки) КонецЦикла;
    Возврат Результат;
КонецФункции

// основано на процедуре "НоваяТаблицаЗначений", http://infostart.ru/public/163853/
Процедура глозСоздатьКолонки(ДЗилиТЗ, знач ИменаКолонокЧерезЗапятую) Экспорт
	Перем КолонкиДЗилиТЗ;
	ИменаКолонокЧерезЗапятую = СтрЗаменить(СтрЗаменить(СтрЗаменить(ИменаКолонокЧерезЗапятую, Символы.Таб, ""), Символы.ПС, ""), " ", "");
	КолонкиДЗилиТЗ = ДЗилиТЗ.Колонки;
	//---> //http://infostart.ru/public/71130/#Pro_bystrye_massivy
	МассивИменКолонок = ЗначениеИзСтрокиВнутр("{""#"",51e7a0d2-530b-11d4-b98a-008048da3034,{0,{""S"",""" + СтрЗаменить(СтрЗаменить(ИменаКолонокЧерезЗапятую, """", """"""), ",", """},{""S"",""") + """}}}");
    Для Каждого ИмяКолонки Из МассивИменКолонок Цикл КолонкиДЗилиТЗ.Добавить(ИмяКолонки) КонецЦикла;
КонецПроцедуры

Процедура глозСообщитьОбОшибкеВыполненияКода(знач ТекстОшибки, тШаблон, Код, Форма, РедакторКода, СмещениеНП=0) Экспорт
	Перем НачСтр, НачКол, КонСтр, КонКол;
	НачСтр=0; НачКол=0; КонСтр=0; КонКол=0; НомСтр=0; НомКол=0;
	ТекстОшибки = СокрЛП(ТекстОшибки);
	П = Найти(ТекстОшибки, тШаблон);
	Если тШаблон="" или П<=0 Тогда
		НомСтр = 0;
		Если тШаблон<>"" Тогда
			Стр = СтрЗаменить(глозСловоМежду("123 "+ТекстОшибки, "123", "{(", ")}"), ",", Символы.ПС);
			НомСтр = глозВЧисло(СтрПолучитьСтроку(Стр, 1));
			НомКол = Макс(глозВЧисло(СтрПолучитьСтроку(Стр, 2)), 1);
			Если НомСтр>0 Тогда
				РедакторКода.УстановитьГраницыВыделения(НомСтр, НомКол, НомСтр, НомКол);
			КонецЕсли;
		КонецЕсли;
		Сообщить(?(ТекстОшибки="", ОписаниеОшибки(), ТекстОшибки), СтатусСообщения.ОченьВажное);
		Форма.Активизировать();
		Форма.ТекущийЭлемент = РедакторКода;
		Если НомСтр>0 Тогда
			РедакторКода.УстановитьГраницыВыделения(НомСтр, НомКол, НомСтр, НомКол);
		КонецЕсли;
		Возврат;
	КонецЕсли;
	Стр = СтрЗаменить(глозСловоМежду(ТекстОшибки, тШаблон, "{(", ")}"), ",", Символы.ПС);
	НомСтр = глозВЧисло(СтрПолучитьСтроку(Стр, 1));
	НомКол = Макс(глозВЧисло(СтрПолучитьСтроку(Стр, 2)), 1);
	ТекстОшибки = СокрЛ(Сред(ТекстОшибки, П+СтрДлина(тШаблон)));
	Если НомСтр>0 и НомКол>0 Тогда
		Форма.Активизировать();
		Форма.ТекущийЭлемент = РедакторКода;
		НП = СмещениеНП + ПарсерТекстаЗапроса.НомерПозицииВТексте(Код, НомСтр, НомКол);
		РедакторКода.УстановитьГраницыВыделения(НомСтр, НомКол, НомСтр, НомКол);
		Если (НП>0) и (НП<СтрДлина(РедакторКода.ПолучитьТекст())) Тогда
			РедакторКода.УстановитьГраницыВыделения(НП, ПарсерТекстаЗапроса.НайтиКонецСлова(РедакторКода.ПолучитьТекст(), НП+1, ",;*-+=)% "+Символы.Таб+Символы.НПП+Символы.ВТаб+Символы.ВК+Символы.ПФ)+1);
		КонецЕсли;
	КонецЕсли;
	Если СмещениеНП<>0 и НомСтр>0 и НомКол>0 Тогда
		ТекстОшибки = Сред(ТекстОшибки, Найти(ТекстОшибки, "{(")+2);
		ТекстОшибки = Сред(ТекстОшибки, Найти(ТекстОшибки, ")}")+2);
		РедакторКода.ПолучитьГраницыВыделения(НачСтр, НачКол, КонСтр, КонКол);
		ТекстОшибки = "{("+НачСтр+", "+НачКол+")} "+ТекстОшибки;
	КонецЕсли;
	РедакторКода.ПолучитьГраницыВыделения(НачСтр, НачКол, КонСтр, КонКол);
	Сообщить(?(ТекстОшибки="", ОписаниеОшибки(), ТекстОшибки), СтатусСообщения.ОченьВажное);
	Форма.Активизировать();
	Форма.ТекущийЭлемент = РедакторКода;
	РедакторКода.УстановитьГраницыВыделения(НачСтр, НачКол, КонСтр, КонКол);
КонецПроцедуры

Функция глозВыгрузитьДеревоЗначенийВТаблицуЗначений(Дерево, Таблица = Неопределено) Экспорт

    Если Таблица = Неопределено Тогда
        Таблица = Новый ТаблицаЗначений;
        Для Каждого Колонка Из Дерево.Колонки Цикл
            Таблица.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
        КонецЦикла;
    КонецЕсли;
    Для Каждого СтрокаДерева Из Дерево.Строки Цикл
        ЗаполнитьЗначенияСвойств(Таблица.Добавить(), СтрокаДерева);
        глозВыгрузитьДеревоЗначенийВТаблицуЗначений(СтрокаДерева, Таблица);
    КонецЦикла;
    Возврат Таблица;

КонецФункции //ВыгрузитьДеревоЗначенийВТаблицуЗначений()

///--------------------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////////
//// Подсистема "Инструменты разработчика"
////
//// Авторское право (с) 2007, Старых С.А.
//// Разрешается повторное распространение и использование как в виде исходника так и в двоичной форме,
//// с модификациями или без, при соблюдении следующих условий: 
//// - При повторном распространении исходного кода должно оставаться указанное выше уведомление об авторском
////   праве, этот список условий и нижеследующий отказ от гарантий. 
//// - При повторном распространении двоичного кода должно воспроизводиться указанное выше уведомление об
////   авторском праве, этот список условий и нижеследующий отказ от гарантий в документации и/или в других
////   материалах, поставляемых при распространении. 
//// 
//// ЭТО ПРОГРАММА ПРЕДОСТАВЛЕНА БЕСПЛАТНО ДЕРЖАТЕЛЯМИ АВТОРСКИХ ПРАВ И/ИЛИ ДРУГИМИ СТОРОНАМИ "КАК ОНА ЕСТЬ"
//// БЕЗ КАКОГО-ЛИБО ВИДА ГАРАНТИЙ, ВЫРАЖЕННЫХ ЯВНО ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ИМИ,
//// ПОДРАЗУМЕВАЕМЫЕ ГАРАНТИИ КОММЕРЧЕСКОЙ ЦЕННОСТИ И ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ. НИ В КОЕМ СЛУЧАЕ,
//// ЕСЛИ НЕ ТРЕБУЕТСЯ СООТВЕТСТВУЮЩИМ ЗАКОНОМ, ИЛИ НЕ УСТАНОВЛЕНО В УСНОЙ ФОРМЕ, НИ ОДИН ДЕРЖАТЕЛЬ АВТОРСКИХ
//// ПРАВ И НИ ОДНО ДРУГОЕ ЛИЦО, КОТОРОЕ МОЖЕТ ИЗМЕНЯТЬ И/ИЛИ ПОВТОРНО РАСПРОСТРАНЯТЬ ПРОГРАММУ, КАК БЫЛО
//// РАЗРЕШЕНО ВЫШЕ, НЕ ОТВЕТСТВЕННЫ ПЕРЕД ВАМИ ЗА УБЫТКИ, ВКЛЮЧАЯ ЛЮБЫЕ ОБЩИЕ, СЛУЧАЙНЫЕ, СПЕЦИАЛЬНЫЕ ИЛИ
//// ПОСЛЕДОВАВШИЕ УБЫТКИ, ПРОИСТЕКАЮЩИЕ ИЗ ИСПОЛЬЗОВАНИЯ ИЛИ НЕВОЗМОЖНОСТИ ИСПЛЬЗОВАНИЯ ПРОГРАММЫ (ВКЛЮЧАЯ,
//// НО НЕ ОГРАНИЧИВАЯСЬ ПОТЕРЕЙ ДАННЫХ, ИЛИ ДАННЫМИ, СТАВШИМИ НЕПРАВИЛЬНЫМИ, ИЛИ ПОТЕРЯМИ ПРИНЕСЕННЫМИ ИЗ-ЗА
//// ВАС ИЛИ ТРЕТЬИХ ЛИЦ, ИЛИ ОТКАЗОМ ПРОГРАММЫ РАБОТАТЬ СОВМЕСТНО С ДРУГИМИ ПРОГРАММАМИ), ДАЖЕ ЕСЛИ ТАКОЙ
//// ДЕРЖАТЕЛЬ ИЛИ ДРУГОЕ ЛИЦО БЫЛИ ИЗВЕЩЕНЫ О ВОЗМОЖНОСТИ ТАКИХ УБЫТКОВ.
//	

//ЛксПолучитьТекущееВремяВМиллисекундах()
Функция глозПолучитьТекущееВремяВМиллисекундах() Экспорт
	
	Возврат ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	//Попытка
	//	Scr = Новый COMОбъект("MSScriptControl.ScriptControl");
	//Исключение
	//	Сообщить(ОписаниеОшибки(), СтатусСообщения.Внимание);
	//	Возврат 0;
	//КонецПопытки;
	//Scr.Language = "javascript";
	//Время = Scr.Eval("new Date().getTime()");
	//Возврат Время;
	//
КонецФункции